<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mobile BabylonJS Demo</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        section {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            scroll-snap-align: start;
            position: relative;
        }

        .container {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        #section1 {
            background-color: #f0f0f0;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #section1 img:first-child {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        #section1 img:nth-child(2) {
            height: calc(100% - var(--top-image-height));
            width: 100%;
            object-fit: cover;
        }

        #section1 .floater1 {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            right: 20px;
            width: 48px;
            height: 48px;
        }

        #section1 .floater2 {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 20px;
            width: 80px;
            height: 8px;
        }

        #section2 {
            background-color: #ffffff;
            position: relative;
        }

        #section2 img {
            width: 100%;
            height: auto;
            object-fit: contain;
            align-self: flex-start;
            margin-top: 55px;
            display: block;
        }

        #section2 .section2_floater {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: auto;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            pointer-events: none;
            z-index: 1;
        }

        #dragOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        #section3 {
            position: relative;
        }

        #section3 img:not(.arrow-button):not(.room-button) {
            position: absolute;
            top: 55px;
            left: 0;
            width: 100%;
            height: auto;
            object-fit: contain;
            z-index: 2;
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button {
            position: absolute;
            top: 50%;
            width: 48px;
            height: 48px;
            transform: translateY(-50%);
            z-index: 3;
            cursor: pointer;
            transition: transform 0.1s ease, right 0.3s ease, left 0.3s ease;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            outline: none;
        }

        #section3 .arrow-button:focus {
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        #section3 .arrow-button.right {
            right: 20px;
            left: auto;
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button.left {
            left: 20px;
            right: auto;
            transform: translateY(-50%) rotate(180deg);
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button:active {
            transform: translateY(-50%) scale(0.9);
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button.left:active {
            transform: translateY(-50%) rotate(180deg) scale(0.9);
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .room-buttons-container {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 0;
            right: 0;
            height: 56px;
            overflow-x: auto;
            white-space: nowrap;
            z-index: 3;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }

        #section3 .room-buttons-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari and Opera */
        }

        #section3 .room-button {
            height: 56px;
            width: auto;
            display: inline-block;
            margin-right: 10px;
            vertical-align: top;
            cursor: pointer;
        }

        #section3 .room-button:first-child {
            margin-left: 20px;
        }

        #section3 .room-button:last-child {
            margin-right: 20px;
        }

        #section4 {
            background-color: #ffffff;
            position: relative;
        }

        #section4 img {
            width: 100%;
            height: auto;
            object-fit: contain;
            align-self: flex-start;
            margin-top: 55px;
        }

        #section4 .section4_floater {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <section id="section1">
            <img src="./UI/section1_top.png" alt="Top image">
            <img src="./UI/section1_bottom.png" alt="Bottom image">
            <img src="./UI/section1_floater1.png" alt="Floating image 1" class="floater1">
            <img src="./UI/section1_floater2.png" alt="Floating image 2" class="floater2">
        </section>

        <section id="section2">
            <img src="./UI/section2_top.png" alt="Section 2 Top image">
            <img src="./UI/section2_floater.png" alt="Section 2 Floating image" class="section2_floater">
        </section>

        <section id="section3">
            <canvas id="renderCanvas"></canvas>
            <div id="dragOverlay"></div>
            <img src="./UI/section3_top_layout_firstfloor.png" alt="Section 3 Top Layout" id="floorLayoutImage">
            <img src="./UI/arrowbutton.png" alt="Arrow Button" class="arrow-button right" id="arrowButton" draggable="false">
            <div class="room-buttons-container">
                <img src="./UI/1_room1.png" alt="Room 1" class="room-button" data-active-src="./UI/1_room1_active.png" data-inactive-src="./UI/1_room1.png">
                <img src="./UI/1_room2.png" alt="Room 2" class="room-button" data-active-src="./UI/1_room2_active.png" data-inactive-src="./UI/1_room2.png">
                <img src="./UI/1_room3.png" alt="Room 3" class="room-button" data-active-src="./UI/1_room3_active.png" data-inactive-src="./UI/1_room3.png">
                <img src="./UI/1_kitchen.png" alt="Kitchen" class="room-button" data-active-src="./UI/1_kitchen_active.png" data-inactive-src="./UI/1_kitchen.png">
                <img src="./UI/1_bathroom1.png" alt="Bathroom 1" class="room-button" data-active-src="./UI/1_bathroom1_active.png" data-inactive-src="./UI/1_bathroom1.png">
                <img src="./UI/1_bathroom2.png" alt="Bathroom 2" class="room-button" data-active-src="./UI/1_bathroom2_active.png" data-inactive-src="./UI/1_bathroom2.png">
                <img src="./UI/1_landing.png" alt="Landing" class="room-button" data-active-src="./UI/1_landing_active.png" data-inactive-src="./UI/1_landing.png">
                <img src="./UI/1_sunroom.png" alt="Sunroom" class="room-button" data-active-src="./UI/1_sunroom_active.png" data-inactive-src="./UI/1_sunroom.png">
                <img src="./UI/1_terrace.png" alt="Terrace" class="room-button" data-active-src="./UI/1_terrace_active.png" data-inactive-src="./UI/1_terrace.png">
                <img src="./UI/1_wardrobe.png" alt="Wardrobe" class="room-button" data-active-src="./UI/1_wardrobe_active.png" data-inactive-src="./UI/1_wardrobe.png">
                <img src="./UI/1_wc.png" alt="WC" class="room-button" data-active-src="./UI/1_wc_active.png" data-inactive-src="./UI/1_wc.png">
            </div>
        </section>

        <section id="section4">
            <img src="./UI/section4_top.png" alt="Section 4 Top image">
            <img src="./UI/section4_floater.png" alt="Section 4 Floating image" class="section4_floater">
        </section>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('renderCanvas');
            const dragOverlay = document.getElementById('dragOverlay');
            const engine = new BABYLON.Engine(canvas, true);
            const arrowButton = document.getElementById('arrowButton');
            const floorLayoutImage = document.getElementById('floorLayoutImage');
            const roomButtons = document.querySelectorAll('.room-button');
            let activeButton = null;
            let groundFloorMesh; // Declare groundFloorMesh at a higher scope
            let firstFloorMesh; // Declare firstFloorMesh at a higher scope
            let isGroundFloorView = false;
            let hasCompletedInitialAnimation = false;
            let visibilityTimeout;

            // Room button click handler
            roomButtons.forEach(button => {
                button.addEventListener('click', function() {
                    if (activeButton === this) {
                        // If clicking the active button, deactivate it
                        this.src = this.dataset.inactiveSrc;
                        activeButton = null;
                    } else {
                        // Deactivate the currently active button if there is one
                        if (activeButton) {
                            activeButton.src = activeButton.dataset.inactiveSrc;
                        }
                        // Activate the clicked button
                        this.src = this.dataset.activeSrc;
                        activeButton = this;
                    }
                });
            });

            // Arrow button click/tap handler
            arrowButton.addEventListener('click', function() {
                this.src = './UI/arrowbutton_active.png';
                setTimeout(() => {
                    this.src = './UI/arrowbutton.png';
                }, 100);

                if (!isGroundFloorView) {
                    // Animate camera target to ground floor
                    if (groundFloorMesh) {
                        BABYLON.Animation.CreateAndStartAnimation(
                            "cameraTargetSwitch",
                            camera,
                            "target",
                            30,
                            7,
                            camera.target,
                            groundFloorMesh.position,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                        
                        // Make ground floor visible immediately
                        groundFloorMesh.setEnabled(true);
                        // Set timeout to hide first floor after 1 second
                        clearTimeout(visibilityTimeout);
                        visibilityTimeout = setTimeout(() => {
                            firstFloorMesh.setEnabled(false);
                        }, 200);
                        
                        // Update floor layout image
                        floorLayoutImage.src = './UI/section3_top_layout_groundfloor.png';
                    }
                    // Move button to left side
                    this.classList.remove('right');
                    this.classList.add('left');
                    isGroundFloorView = true;
                } else {
                    // Animate camera target back to first floor
                    if (firstFloorMesh) {
                        BABYLON.Animation.CreateAndStartAnimation(
                            "cameraTargetSwitch",
                            camera,
                            "target",
                            30,
                            7,
                            camera.target,
                            firstFloorMesh.position,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                        
                        // Make first floor visible immediately
                        firstFloorMesh.setEnabled(true);
                        // Set timeout to hide ground floor after 1 second
                        clearTimeout(visibilityTimeout);
                        visibilityTimeout = setTimeout(() => {
                            groundFloorMesh.setEnabled(false);
                        }, 200);
                        
                        // Update floor layout image
                        floorLayoutImage.src = './UI/section3_top_layout_firstfloor.png';
                    }
                    // Move button to right side
                    this.classList.remove('left');
                    this.classList.add('right');
                    isGroundFloorView = false;
                }
            });

            // Calculate and set the top image height CSS variable
            const topImage = document.querySelector('#section1 img:first-child');
            topImage.addEventListener('load', () => {
                const topImageHeight = topImage.offsetHeight;
                document.documentElement.style.setProperty('--top-image-height', topImageHeight + 'px');
            });

            let isDragging = false;
            let lastX = 0;
            let isHorizontalDrag = false;
            let startY = 0;
            let camera;
            let hasAnimatedCamera = false;
            let startTime = 0;
            const clickThreshold = 200; // milliseconds to distinguish between click and drag

            // Camera inertia variables
            let angularVelocity = 0;
            const friction = 0.95; // Friction coefficient (0-1)
            const minVelocity = 0.001; // Minimum velocity before stopping
            let lastDragTime = 0;
            let isInertiaActive = false;

            // Handle both mouse and touch events
            const startDrag = (e) => {
                isDragging = true;
                isHorizontalDrag = false;
                lastX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                startTime = Date.now();
                lastDragTime = startTime;
                angularVelocity = 0;
                isInertiaActive = false;
            };

            const endDrag = (e) => {
                const endTime = Date.now();
                const duration = endTime - startTime;

                if (isHorizontalDrag) {
                    const timeDelta = endTime - lastDragTime;
                    if (timeDelta > 0) {
                        isInertiaActive = true;
                    }
                }

                // Only check for mesh clicks if it was a quick tap/click (not a drag)
                if (duration < clickThreshold && !isHorizontalDrag) {
                    const currentX = e.type.includes('mouse') ? e.clientX : 
                                   (e.changedTouches ? e.changedTouches[0].clientX : lastX);
                    const currentY = e.type.includes('mouse') ? e.clientY : 
                                   (e.changedTouches ? e.changedTouches[0].clientY : startY);
                    
                    // Get the canvas position
                    const canvasRect = canvas.getBoundingClientRect();
                    // Convert screen coordinates to scene picking ray
                    const pickResult = scene.pick(
                        currentX - canvasRect.left,
                        currentY - canvasRect.top
                    );
                    
                    if (pickResult.hit) {
                        console.log("Clicked mesh:", pickResult.pickedMesh.name);
                        // Add your mesh interaction logic here
                    }
                }

                isDragging = false;
                isHorizontalDrag = false;
            };

            const onDrag = (e) => {
                if (!isDragging) return;
                
                const currentX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                const currentTime = Date.now();
                
                // Determine if this is a horizontal drag
                if (!isHorizontalDrag) {
                    const deltaX = Math.abs(currentX - lastX);
                    const deltaY = Math.abs(currentY - startY);
                    
                    // If horizontal movement is greater than vertical, treat as horizontal drag
                    if (deltaX > deltaY) {
                        isHorizontalDrag = true;
                    }
                }

                if (isHorizontalDrag) {
                    const deltaX = currentX - lastX;
                    const timeDelta = currentTime - lastDragTime;
                    
                    if (timeDelta > 0) {
                        // Calculate angular velocity (radians per millisecond)
                        angularVelocity = (deltaX * 0.005) / timeDelta;
                    }
                    
                    // Update camera alpha (rotation around Y axis)
                    camera.alpha -= deltaX * 0.005;
                    
                    lastX = currentX;
                    lastDragTime = currentTime;
                    
                    // Prevent default only for horizontal drags
                    e.preventDefault();
                }
                // If not horizontal drag, let the default scroll behavior happen
            };

            // Mouse events
            dragOverlay.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', endDrag);

            // Touch events
            dragOverlay.addEventListener('touchstart', startDrag);
            window.addEventListener('touchmove', onDrag);
            window.addEventListener('touchend', endDrag);

            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(1, 1, 1);

                // Camera
                camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 3, 30, new BABYLON.Vector3(30, 15, 0), scene);
                camera.attachControl(canvas, false);
                
                // Disable camera controls
                camera.inputs.clear();

                // Light
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

                // Load first floor model (centered)
                BABYLON.SceneLoader.ImportMeshAsync("", "./3D/", "firstfloor.glb", scene).then(function (result) {
                    console.log("First floor model loaded successfully");
                    firstFloorMesh = result.meshes[0];
                }).catch(function(error) {
                    console.error("Error loading first floor model:", error);
                });

                // Load ground floor model (offset on X axis)
                BABYLON.SceneLoader.ImportMeshAsync("", "./3D/", "groundfloor.glb", scene).then(function (result) {
                    console.log("Ground floor model loaded successfully");
                    groundFloorMesh = result.meshes[0];
                    groundFloorMesh.position.x = 30;
                    groundFloorMesh.setEnabled(false); // Initially hide ground floor
                    
                    // Set initial camera position and target after ground floor loads
                    camera.position = new BABYLON.Vector3(30, 15, -15);
                    camera.setTarget(groundFloorMesh.position);
                }).catch(function(error) {
                    console.error("Error loading ground floor model:", error);
                });

                // Add intersection observer for section transitions
                const section3 = document.getElementById('section3');
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !hasAnimatedCamera && groundFloorMesh && firstFloorMesh) {
                            hasAnimatedCamera = true;
                            
                            // Make both models visible for initial animation
                            groundFloorMesh.setEnabled(true);
                            firstFloorMesh.setEnabled(true);
                            
                            // Animate camera position
                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraMove",
                                camera,
                                "position",
                                30,
                                30,
                                camera.position,
                                new BABYLON.Vector3(0, 15, -15),
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                            );

                            // Animate camera target
                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraTarget",
                                camera,
                                "target",
                                30,
                                7,
                                camera.target,
                                firstFloorMesh.position,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                            );

                            // After initial animation completes, hide ground floor
                            setTimeout(() => {
                                hasCompletedInitialAnimation = true;
                                groundFloorMesh.setEnabled(false);
                            }, 1000);
                        }
                    });
                }, { threshold: 0.5 });

                observer.observe(section3);

                // Add before render observer for inertia
                scene.onBeforeRenderObservable.add(() => {
                    if (isInertiaActive && !isDragging) {
                        camera.alpha -= angularVelocity * 16; // Assuming 60fps, multiply by ~16ms
                        angularVelocity *= friction;
                        
                        if (Math.abs(angularVelocity) < minVelocity) {
                            isInertiaActive = false;
                            angularVelocity = 0;
                        }
                    }
                });

                return scene;
            }

            const scene = createScene();

            engine.runRenderLoop(function() {
                scene.render();
            });

            window.addEventListener('resize', function() {
                // Existing resize handler for the engine
                engine.resize();
                
                // Force layout recalculation for safe areas
                document.documentElement.style.setProperty('--dummy', 'none');
                setTimeout(() => {
                    document.documentElement.style.removeProperty('--dummy');
                }, 0);
            });

            // Some browsers also support this event for safe area changes
            if ('ondeviceinfochange' in window) {
                window.addEventListener('deviceinfochange', function() {
                    // Force layout recalculation
                    document.documentElement.style.setProperty('--dummy', 'none');
                    setTimeout(() => {
                        document.documentElement.style.removeProperty('--dummy');
                    }, 0);
                });
            }
        });
    </script>
</body>
</html>
