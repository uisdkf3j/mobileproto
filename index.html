<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mobile BabylonJS Demo</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        section {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            scroll-snap-align: start;
            position: relative;
        }

        .container {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        #section1 {
            background-color: #f0f0f0;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #section1 img:first-child {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        #section1 img:nth-child(2) {
            height: calc(100% - var(--top-image-height));
            width: 100%;
            object-fit: cover;
        }

        #section1 .floater1 {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            right: 20px;
            width: 48px;
            height: 48px;
        }

        #section1 .floater2 {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 20px;
            width: 80px;
            height: 8px;
        }

        #section2 {
            background-color: #ffffff;
            position: relative;
        }

        #section2 img {
            width: 100%;
            height: auto;
            object-fit: contain;
            align-self: flex-start;
            margin-top: 55px;
            display: block;
        }

        #section2 .section2_floater {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: auto;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            pointer-events: none;
        }

        #dragOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        #section3 {
            position: relative;
        }

        #section3 img {
            position: absolute;
            top: 55px;
            left: 0;
            width: 100%;
            height: auto;
            object-fit: contain;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div class="container">
        <section id="section1">
            <img src="./UI/section1_top.png" alt="Top image">
            <img src="./UI/section1_bottom.png" alt="Bottom image">
            <img src="./UI/section1_floater1.png" alt="Floating image 1" class="floater1">
            <img src="./UI/section1_floater2.png" alt="Floating image 2" class="floater2">
        </section>

        <section id="section2">
            <img src="./UI/section2_top.png" alt="Section 2 Top image">
            <img src="./UI/section2_floater.png" alt="Section 2 Floating image" class="section2_floater">
        </section>

        <section id="section3">
            <canvas id="renderCanvas"></canvas>
            <div id="dragOverlay"></div>
            <img src="./UI/section3_top_layout_groundfloor.png" alt="Section 3 Top Layout">
        </section>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('renderCanvas');
            const dragOverlay = document.getElementById('dragOverlay');
            const engine = new BABYLON.Engine(canvas, true);

            // Calculate and set the top image height CSS variable
            const topImage = document.querySelector('#section1 img:first-child');
            topImage.addEventListener('load', () => {
                const topImageHeight = topImage.offsetHeight;
                document.documentElement.style.setProperty('--top-image-height', topImageHeight + 'px');
            });

            let isDragging = false;
            let lastX = 0;
            let isHorizontalDrag = false;
            let startY = 0;
            let camera;
            let startTime = 0;
            const clickThreshold = 200; // milliseconds to distinguish between click and drag

            // Handle both mouse and touch events
            const startDrag = (e) => {
                isDragging = true;
                isHorizontalDrag = false;
                lastX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                startTime = Date.now();
            };

            const endDrag = (e) => {
                const endTime = Date.now();
                const duration = endTime - startTime;

                // Only check for mesh clicks if it was a quick tap/click (not a drag)
                if (duration < clickThreshold && !isHorizontalDrag) {
                    const currentX = e.type.includes('mouse') ? e.clientX : 
                                   (e.changedTouches ? e.changedTouches[0].clientX : lastX);
                    const currentY = e.type.includes('mouse') ? e.clientY : 
                                   (e.changedTouches ? e.changedTouches[0].clientY : startY);
                    
                    // Get the canvas position
                    const canvasRect = canvas.getBoundingClientRect();
                    // Convert screen coordinates to scene picking ray
                    const pickResult = scene.pick(
                        currentX - canvasRect.left,
                        currentY - canvasRect.top
                    );
                    
                    if (pickResult.hit) {
                        console.log("Clicked mesh:", pickResult.pickedMesh.name);
                        // Add your mesh interaction logic here
                    }
                }

                isDragging = false;
                isHorizontalDrag = false;
            };

            const onDrag = (e) => {
                if (!isDragging) return;
                
                const currentX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                
                // Determine if this is a horizontal drag
                if (!isHorizontalDrag) {
                    const deltaX = Math.abs(currentX - lastX);
                    const deltaY = Math.abs(currentY - startY);
                    
                    // If horizontal movement is greater than vertical, treat as horizontal drag
                    if (deltaX > deltaY) {
                        isHorizontalDrag = true;
                    }
                }

                if (isHorizontalDrag) {
                    const deltaX = currentX - lastX;
                    // Update camera alpha (rotation around Y axis)
                    // Convert pixel movement to radians (adjust sensitivity as needed)
                    const rotationSensitivity = 0.005;
                    camera.alpha -= deltaX * rotationSensitivity;
                    
                    lastX = currentX;
                    
                    // Prevent default only for horizontal drags
                    e.preventDefault();
                }
                // If not horizontal drag, let the default scroll behavior happen
            };

            // Mouse events
            dragOverlay.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', endDrag);

            // Touch events
            dragOverlay.addEventListener('touchstart', startDrag);
            window.addEventListener('touchmove', onDrag);
            window.addEventListener('touchend', endDrag);

            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(1, 1, 1);

                // Camera
                camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 3, 15, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvas, false);
                
                // Disable camera controls
                camera.inputs.clear();

                // Light
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

                // Load 3D model
                BABYLON.SceneLoader.ImportMeshAsync("", "./3D/", "hitboxes.glb", scene).then(function (result) {
                    console.log("Model loaded successfully");
                }).catch(function(error) {
                    console.error("Error loading model:", error);
                });

                return scene;
            }

            const scene = createScene();

            engine.runRenderLoop(function() {
                scene.render();
            });

            window.addEventListener('resize', function() {
                // Existing resize handler for the engine
                engine.resize();
                
                // Force layout recalculation for safe areas
                document.documentElement.style.setProperty('--dummy', 'none');
                setTimeout(() => {
                    document.documentElement.style.removeProperty('--dummy');
                }, 0);
            });

            // Some browsers also support this event for safe area changes
            if ('ondeviceinfochange' in window) {
                window.addEventListener('deviceinfochange', function() {
                    // Force layout recalculation
                    document.documentElement.style.setProperty('--dummy', 'none');
                    setTimeout(() => {
                        document.documentElement.style.removeProperty('--dummy');
                    }, 0);
                });
            }
        });
    </script>
</body>
</html>
