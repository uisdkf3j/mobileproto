<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mobile BabylonJS Demo</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        section {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            scroll-snap-align: start;
            position: relative;
        }

        .container {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        #section1 {
            background-color: #f0f0f0;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #section1 img:first-child {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        #section1 img:nth-child(2) {
            height: calc(100% - var(--top-image-height));
            width: 100%;
            object-fit: cover;
        }

        #section1 .floater1 {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            right: 20px;
            width: 48px;
            height: 48px;
        }

        #section1 .floater2 {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 20px;
            width: 80px;
            height: 8px;
        }

        #section2 {
            background-color: #ffffff;
            position: relative;
        }

        #section2 img {
            width: 100%;
            height: auto;
            object-fit: contain;
            align-self: flex-start;
            margin-top: 55px;
            display: block;
        }

        #section2 .section2_floater {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: auto;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            pointer-events: none;
            z-index: 1;
        }

        #dragOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        #section3 {
            position: relative;
        }

        #section3 img:not(.arrow-button):not(.room-button):not(.back-button) {
            position: absolute;
            top: 55px;
            left: 0;
            width: 100%;
            height: auto;
            object-fit: contain;
            z-index: 2;
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button {
            position: absolute;
            top: 50%;
            width: 36px;
            height: 36px;
            transform: translateY(-50%);
            z-index: 3;
            cursor: pointer;
            transition: transform 0.1s ease, right 0.3s ease, left 0.3s ease;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            outline: none;
        }

        #section3 .arrow-button:focus {
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        #section3 .arrow-button.right {
            right: 20px;
            left: auto;
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button.left {
            left: 20px;
            right: auto;
            transform: translateY(-50%) rotate(180deg);
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button:active {
            transform: translateY(-50%) scale(0.9);
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .arrow-button.left:active {
            transform: translateY(-50%) rotate(180deg) scale(0.9);
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
        }

        #section3 .room-buttons-container {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 0;
            right: 0;
            height: 56px;
            overflow-x: auto;
            white-space: nowrap;
            z-index: 3;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }

        #section3 .room-buttons-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari and Opera */
        }

        #section3 .room-button {
            height: 48px;
            width: auto;
            display: inline-block;
            margin-right: 10px;
            vertical-align: top;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;  /* Remove blue highlight on tap */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            outline: none;
        }

        #section3 .room-button:focus {
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        #section3 .room-button:first-child {
            margin-left: 20px;
        }

        #section3 .room-button:last-child {
            margin-right: 20px;
        }

        #section3 .back-button {
            position: absolute;
            bottom: calc(max(30px, env(safe-area-inset-bottom, 30px)) + 78px);
            left: 50%;
            transform: translateX(-50%);
            height: 50px; /* Reduced by 1.5x from 56px */
            width: auto;
            z-index: 3;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            display: none; /* Initially hidden */
        }

        #section4 {
            background-color: #ffffff;
            position: relative;
        }

        #section4 img {
            width: 100%;
            height: auto;
            object-fit: contain;
            align-self: flex-start;
            margin-top: 55px;
        }

        #section4 .section4_floater {
            position: absolute;
            bottom: max(30px, env(safe-area-inset-bottom, 30px));
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <section id="section1">
            <img src="./UI/section1_top.png" alt="Top image">
            <img src="./UI/section1_bottom.png" alt="Bottom image">
            <img src="./UI/section1_floater1.png" alt="Floating image 1" class="floater1">
            <img src="./UI/section1_floater2.png" alt="Floating image 2" class="floater2">
        </section>

        <section id="section2">
            <img src="./UI/section2_top.png" alt="Section 2 Top image">
            <img src="./UI/section2_floater.png" alt="Section 2 Floating image" class="section2_floater">
        </section>

        <section id="section3">
            <canvas id="renderCanvas"></canvas>
            <div id="dragOverlay"></div>
            <img src="./UI/section3_top_layout_firstfloor.png" alt="Section 3 Top Layout" id="floorLayoutImage">
            <img src="./UI/arrowbutton.png" alt="Arrow Button" class="arrow-button right" id="arrowButton" draggable="false">
            <img src="./UI/back.png" alt="Back Button" class="back-button">
            <div class="room-buttons-container" id="firstFloorButtons">
                <img src="./UI/1_room1.png" alt="Room 1" class="room-button" data-active-src="./UI/1_room1_active.png" data-inactive-src="./UI/1_room1.png">
                <img src="./UI/1_room2.png" alt="Room 2" class="room-button" data-active-src="./UI/1_room2_active.png" data-inactive-src="./UI/1_room2.png">
                <img src="./UI/1_room3.png" alt="Room 3" class="room-button" data-active-src="./UI/1_room3_active.png" data-inactive-src="./UI/1_room3.png">
                <img src="./UI/1_kitchen.png" alt="Kitchen" class="room-button" data-active-src="./UI/1_kitchen_active.png" data-inactive-src="./UI/1_kitchen.png">
                <img src="./UI/1_bathroom1.png" alt="Bathroom 1" class="room-button" data-active-src="./UI/1_bathroom1_active.png" data-inactive-src="./UI/1_bathroom1.png">
                <img src="./UI/1_bathroom2.png" alt="Bathroom 2" class="room-button" data-active-src="./UI/1_bathroom2_active.png" data-inactive-src="./UI/1_bathroom2.png">
                <img src="./UI/1_landing.png" alt="Landing" class="room-button" data-active-src="./UI/1_landing_active.png" data-inactive-src="./UI/1_landing.png">
                <img src="./UI/1_sunroom.png" alt="Sunroom" class="room-button" data-active-src="./UI/1_sunroom_active.png" data-inactive-src="./UI/1_sunroom.png">
                <img src="./UI/1_terrace.png" alt="Terrace" class="room-button" data-active-src="./UI/1_terrace_active.png" data-inactive-src="./UI/1_terrace.png">
                <img src="./UI/1_wardrobe.png" alt="Wardrobe" class="room-button" data-active-src="./UI/1_wardrobe_active.png" data-inactive-src="./UI/1_wardrobe.png">
                <img src="./UI/1_wc.png" alt="WC" class="room-button" data-active-src="./UI/1_wc_active.png" data-inactive-src="./UI/1_wc.png">
            </div>
            <div class="room-buttons-container" id="groundFloorButtons" style="display: none;">
                <img src="./UI/0_room1.png" alt="Room 1" class="room-button" data-active-src="./UI/0_room1_active.png" data-inactive-src="./UI/0_room1.png">
                <img src="./UI/0_room2.png" alt="Room 2" class="room-button" data-active-src="./UI/0_room2_active.png" data-inactive-src="./UI/0_room2.png">
                <img src="./UI/0_room3.png" alt="Room 3" class="room-button" data-active-src="./UI/0_room3_active.png" data-inactive-src="./UI/0_room3.png">
                <img src="./UI/0_room4.png" alt="Room 4" class="room-button" data-active-src="./UI/0_room4_active.png" data-inactive-src="./UI/0_room4.png">
                <img src="./UI/0_room5.png" alt="Room 5" class="room-button" data-active-src="./UI/0_room5_active.png" data-inactive-src="./UI/0_room5.png">
                <img src="./UI/0_garage.png" alt="Garage" class="room-button" data-active-src="./UI/0_garage_active.png" data-inactive-src="./UI/0_garage.png">
                <img src="./UI/0_landing.png" alt="Landing" class="room-button" data-active-src="./UI/0_landing_active.png" data-inactive-src="./UI/0_landing.png">
                <img src="./UI/0_utilityroom.png" alt="Utility Room" class="room-button" data-active-src="./UI/0_utilityroom_active.png" data-inactive-src="./UI/0_utilityroom.png">
                <img src="./UI/0_wc.png" alt="WC" class="room-button" data-active-src="./UI/0_wc_active.png" data-inactive-src="./UI/0_wc.png">
            </div>
        </section>

        <section id="section4">
            <img src="./UI/section4_top.png" alt="Section 4 Top image">
            <img src="./UI/section4_floater.png" alt="Section 4 Floating image" class="section4_floater">
        </section>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('renderCanvas');
            const dragOverlay = document.getElementById('dragOverlay');
            // Increase canvas scale for better resolution on high DPI devices
            const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
            engine.setHardwareScalingLevel(1 / window.devicePixelRatio);
            const arrowButton = document.getElementById('arrowButton');
            const floorLayoutImage = document.getElementById('floorLayoutImage');
            const firstFloorButtons = document.getElementById('firstFloorButtons');
            const groundFloorButtons = document.getElementById('groundFloorButtons');
            const backButton = document.querySelector('.back-button');
            let activeButton = null;
            let groundFloorMesh; 
            let firstFloorMesh;
            let isGroundFloorView = false;
            let hasCompletedInitialAnimation = false;
            let visibilityTimeout;

            // Back button click handler
            backButton.addEventListener('click', function() {
                console.log('Back button clicked');
                if (activeButton) {
                    console.log('Deactivating button:', activeButton.alt);
                    activeButton.src = activeButton.dataset.inactiveSrc;
                    activeButton = null;
                    backButton.style.display = 'none';
                    arrowButton.style.display = 'block';
                    
                    const targetMesh = isGroundFloorView ? groundFloorMesh : firstFloorMesh;
                    if (targetMesh) {
                        console.log('Target mesh position:', {
                            x: targetMesh.position.x,
                            y: targetMesh.position.y,
                            z: targetMesh.position.z
                        });
                        BABYLON.Animation.CreateAndStartAnimation(
                            "cameraTargetRoom",
                            camera,
                            "target",
                            30,
                            7,
                            camera.target,
                            targetMesh.position,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                        BABYLON.Animation.CreateAndStartAnimation(
                            "cameraRadiusReset",
                            camera,
                            "radius",
                            30,
                            7,
                            camera.radius,
                            15,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                        
                     }
                    } else {
                        console.warn('Target mesh not found for camera reset');
                }
            });

            // Room button click handler for both floors
            const setupRoomButtons = (container) => {
                const buttons = container.querySelectorAll('.room-button');
                buttons.forEach(button => {
                    button.addEventListener('click', function() {
                        console.log('Room button clicked:', this.alt);
                        if (activeButton === this) {
                            console.log('Deactivating current button:', this.alt);
                            this.src = this.dataset.inactiveSrc;
                            activeButton = null;
                            backButton.style.display = 'none';
                            arrowButton.style.display = 'block';
                            
                            const targetMesh = isGroundFloorView ? groundFloorMesh : firstFloorMesh;
                            if (targetMesh) {
                                console.log('Resetting camera target to floor mesh:', isGroundFloorView ? 'ground floor' : 'first floor');
                                BABYLON.Animation.CreateAndStartAnimation(
                                    "cameraTargetReset",
                                    camera,
                                    "target",
                                    30,
                                    7,
                                    camera.target,
                                    targetMesh.position,
                                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                );
                                BABYLON.Animation.CreateAndStartAnimation(
                                    "cameraRadiusReset",
                                    camera,
                                    "radius",
                                    30,
                                    7,
                                    camera.radius,
                                    15,
                                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                );
                            } else {
                                console.warn('Target mesh not found for camera reset');
                            }
                        } else {
                            if (activeButton) {
                                console.log('Deactivating previous button:', activeButton.alt);
                                activeButton.src = activeButton.dataset.inactiveSrc;
                            }
                            console.log('Activating new button:', this.alt);
                            this.src = this.dataset.activeSrc;
                            activeButton = this;
                            backButton.style.display = 'block';
                            arrowButton.style.display = 'none';
                            
                            const imgSrc = this.src;
                            const meshName = imgSrc.split('/').pop().split('_active.png')[0];
                            console.log('Looking for mesh with name:', meshName);
                            
                            const targetMesh = scene.getMeshByName(meshName);
                            if (targetMesh) {
                                console.log('Found target mesh:', meshName);
                                const xOffset = meshName.startsWith('0') ? 30 : 0;
                                const invertedPosition = new BABYLON.Vector3(
                                    -targetMesh.position.x + xOffset,
                                    targetMesh.position.y,
                                    targetMesh.position.z
                                );
                                BABYLON.Animation.CreateAndStartAnimation(
                                    "cameraTargetRoom",
                                    camera,
                                    "target",
                                    30,
                                    7,
                                    camera.target,
                                    invertedPosition,
                                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                );
                                
                                // Set camera radius based on the room
                                const radiusMap = {
                                    "0_garage": 6,
                                    "0_landing": 5,
                                    "0_room1": 4,
                                    "0_room2": 4,
                                    "0_room3": 4.5,
                                    "0_room4": 5,
                                    "0_room5": 4,
                                    "0_utilityroom": 4,
                                    "0_wc": 3,
                                    "1_bathroom1": 3.5,
                                    "1_bathroom2": 3.5,
                                    "1_kitchen": 4.5,
                                    "1_landing": 4.5,
                                    "1_room1": 4.5,
                                    "1_room2": 4,
                                    "1_room3": 4,
                                    "1_sunroom": 4.5,
                                    "1_terrace": 6,
                                    "1_wardrobe": 3,
                                    "1_wc": 3
                                };
                                const targetRadius = radiusMap[meshName] || 15; // Default radius if not found
                                BABYLON.Animation.CreateAndStartAnimation(
                                    "cameraRadiusRoom",
                                    camera,
                                    "radius",
                                    30,
                                    7,
                                    camera.radius,
                                    targetRadius,
                                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                );
                                
                            } else {
                                console.warn('Target mesh not found:', meshName);
                            }
                        }
                    });
                });
            };

            setupRoomButtons(firstFloorButtons);
            setupRoomButtons(groundFloorButtons);

            arrowButton.addEventListener('click', function() {
                console.log('Arrow button clicked, current floor:', isGroundFloorView ? 'ground' : 'first');
                this.src = './UI/arrowbutton_active.png';
                setTimeout(() => {
                    this.src = './UI/arrowbutton.png';
                }, 100);

                if (activeButton) {
                    console.log('Deactivating active button:', activeButton.alt);
                    activeButton.src = activeButton.dataset.inactiveSrc;
                    activeButton = null;
                    backButton.style.display = 'none';
                    arrowButton.style.display = 'block';
                }

                if (!isGroundFloorView) {
                    console.log('Switching to ground floor');
                    if (groundFloorMesh) {
                        console.log('Animating camera to ground floor mesh');
                        BABYLON.Animation.CreateAndStartAnimation(
                            "cameraTargetSwitch",
                            camera,
                            "target",
                            30,
                            7,
                            camera.target,
                            groundFloorMesh.position,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                        
                        groundFloorMesh.setEnabled(true);
                        clearTimeout(visibilityTimeout);
                        visibilityTimeout = setTimeout(() => {
                            firstFloorMesh.setEnabled(false);
                            console.log('First floor mesh hidden');
                        }, 200);
                        
                        floorLayoutImage.src = './UI/section3_top_layout_groundfloor.png';
                        firstFloorButtons.style.display = 'none';
                        groundFloorButtons.style.display = 'block';
                    } else {
                        console.warn('Ground floor mesh not found');
                    }
                    this.classList.remove('right');
                    this.classList.add('left');
                    isGroundFloorView = true;
                } else {
                    console.log('Switching to first floor');
                    if (firstFloorMesh) {
                        console.log('Animating camera to first floor mesh');
                        BABYLON.Animation.CreateAndStartAnimation(
                            "cameraTargetSwitch",
                            camera,
                            "target",
                            30,
                            7,
                            camera.target,
                            firstFloorMesh.position,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                        
                        firstFloorMesh.setEnabled(true);
                        clearTimeout(visibilityTimeout);
                        visibilityTimeout = setTimeout(() => {
                            groundFloorMesh.setEnabled(false);
                            console.log('Ground floor mesh hidden');
                        }, 200);
                        
                        floorLayoutImage.src = './UI/section3_top_layout_firstfloor.png';
                        groundFloorButtons.style.display = 'none';
                        firstFloorButtons.style.display = 'block';
                    } else {
                        console.warn('First floor mesh not found');
                    }
                    this.classList.remove('left');
                    this.classList.add('right');
                    isGroundFloorView = false;
                }
            });

            const topImage = document.querySelector('#section1 img:first-child');
            topImage.addEventListener('load', () => {
                const topImageHeight = topImage.offsetHeight;
                document.documentElement.style.setProperty('--top-image-height', topImageHeight + 'px');
            });

            let isDragging = false;
            let lastX = 0;
            let isHorizontalDrag = false;
            let startY = 0;
            let camera;
            let hasAnimatedCamera = false;
            let startTime = 0;
            const clickThreshold = 200;

            let angularVelocity = 0;
            const friction = 0.95;
            const minVelocity = 0.001;
            let lastDragTime = 0;
            let isInertiaActive = false;

            const startDrag = (e) => {
                isDragging = true;
                isHorizontalDrag = false;
                lastX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                startTime = Date.now();
                lastDragTime = startTime;
                angularVelocity = 0;
                isInertiaActive = false;
            };

            const endDrag = (e) => {
                const endTime = Date.now();
                const duration = endTime - startTime;

                if (isHorizontalDrag) {
                    const timeDelta = endTime - lastDragTime;
                    if (timeDelta > 0) {
                        isInertiaActive = true;
                    }
                }

                if (duration < clickThreshold && !isHorizontalDrag) {
                    const currentX = e.type.includes('mouse') ? e.clientX : 
                                   (e.changedTouches ? e.changedTouches[0].clientX : lastX);
                    const currentY = e.type.includes('mouse') ? e.clientY : 
                                   (e.changedTouches ? e.changedTouches[0].clientY : startY);
                    
                    const canvasRect = canvas.getBoundingClientRect();
                    const pickResult = scene.pick(
                        currentX - canvasRect.left,
                        currentY - canvasRect.top
                    );
                    
                    if (pickResult.hit) {
                        console.log("Clicked mesh:", pickResult.pickedMesh.name);
                    }
                }

                isDragging = false;
                isHorizontalDrag = false;
            };

            const onDrag = (e) => {
                if (!isDragging) return;
                
                const currentX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                const currentTime = Date.now();
                
                if (!isHorizontalDrag) {
                    const deltaX = Math.abs(currentX - lastX);
                    const deltaY = Math.abs(currentY - startY);
                    
                    if (deltaX > deltaY) {
                        isHorizontalDrag = true;
                    }
                }

                if (isHorizontalDrag) {
                    const deltaX = currentX - lastX;
                    const timeDelta = currentTime - lastDragTime;
                    
                    if (timeDelta > 0) {
                        angularVelocity = (deltaX * 0.010) / timeDelta;
                    }
                    
                    camera.alpha -= deltaX * 0.008;
                    
                    lastX = currentX;
                    lastDragTime = currentTime;
                    
                    e.preventDefault();
                }
            };

            dragOverlay.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', endDrag);

            dragOverlay.addEventListener('touchstart', startDrag);
            window.addEventListener('touchmove', onDrag);
            window.addEventListener('touchend', endDrag);

            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(1, 1, 1);

                camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 3, 30, new BABYLON.Vector3(30, 30, 0), scene);
                camera.attachControl(canvas, false);
                camera.inputs.clear();

                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

                // Create custom shader
                BABYLON.Effect.ShadersStore["customVertexShader"] = `
                    precision highp float;
                    attribute vec3 position;
                    attribute vec3 normal;
                    uniform mat4 worldViewProjection;
                    varying vec3 vNormal;
                    void main(void) {
                        vNormal = normal;
                        gl_Position = worldViewProjection * vec4(position, 1.0);
                    }
                `;

                BABYLON.Effect.ShadersStore["customFragmentShader"] = `
                    precision highp float;
                    varying vec3 vNormal;
                    void main(void) {
                        vec3 normalizedNormal = normalize(vNormal);
                        if (normalizedNormal.y > 0.9) {
                            gl_FragColor = vec4(0.122, 0.106, 0.075, 1.0);
                        } else {
                            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                        }
                    }
                `;

                const shaderMaterial = new BABYLON.ShaderMaterial(
                    "customShader",
                    scene,
                    {
                        vertex: "custom",
                        fragment: "custom",
                    },
                    {
                        attributes: ["position", "normal"],
                        uniforms: ["worldViewProjection"]
                    }
                );

                BABYLON.SceneLoader.ImportMeshAsync("", "./3D/", "firstfloor.glb", scene).then(function (result) {
                    console.log("First floor model loaded successfully");
                    firstFloorMesh = result.meshes[0];
                    
                    result.meshes.forEach(mesh => {
                        if (mesh.name.startsWith('1_')) {
                            mesh.visibility = 0;
                        }
                        mesh.material = shaderMaterial;
                        mesh.enableEdgesRendering();
                        mesh.edgesWidth = mesh.name === "GroundFloor_primitive10" ? 2.0 : 2.0;
                        mesh.edgesColor = new BABYLON.Color4(0.121, 0.106, 0.075, 1);
                    });
                }).catch(function(error) {
                    console.error("Error loading first floor model:", error);
                });

                BABYLON.SceneLoader.ImportMeshAsync("", "./3D/", "groundfloor.glb", scene).then(function (result) {
                    console.log("Ground floor model loaded successfully");
                    groundFloorMesh = result.meshes[0];
                    groundFloorMesh.position.x = 30;
                    groundFloorMesh.setEnabled(false);
                    
                    result.meshes.forEach(mesh => {
                        if (mesh.name.startsWith('0_')) {
                            mesh.visibility = 0;
                        }
                        mesh.material = shaderMaterial;
                        mesh.enableEdgesRendering();
                        mesh.edgesWidth = mesh.name === "GroundFloor_primitive10" ? 2.0 : 2.0;
                        mesh.edgesColor = new BABYLON.Color4(0.121, 0.106, 0.075, 1);
                    });
                    
                    camera.position = new BABYLON.Vector3(30, 30, -15);
                    camera.setTarget(groundFloorMesh.position);
                }).catch(function(error) {
                    console.error("Error loading ground floor model:", error);
                });

                const section3 = document.getElementById('section3');
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !hasAnimatedCamera && groundFloorMesh && firstFloorMesh) {
                            console.log('Section 3 visible, starting initial animation');
                            hasAnimatedCamera = true;
                            
                            groundFloorMesh.setEnabled(true);
                            firstFloorMesh.setEnabled(true);
                            
                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraMove",
                                camera,
                                "position",
                                30,
                                45,
                                camera.position,
                                new BABYLON.Vector3(0, 15, -15),
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                            );

                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraTarget",
                                camera,
                                "target",
                                30,
                                10,
                                camera.target,
                                firstFloorMesh.position,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                            );

                            setTimeout(() => {
                                hasCompletedInitialAnimation = true;
                                groundFloorMesh.setEnabled(false);
                            }, 1000);
                        }
                    });
                }, { threshold: 0.5 });

                observer.observe(section3);

                scene.onBeforeRenderObservable.add(() => {
                    if (isInertiaActive && !isDragging) {
                        camera.alpha -= angularVelocity * 16;
                        angularVelocity *= friction;
                        
                        if (Math.abs(angularVelocity) < minVelocity) {
                            isInertiaActive = false;
                            angularVelocity = 0;
                        }
                    }
                });

                return scene;
            }

            const scene = createScene();

            engine.runRenderLoop(function() {
                scene.render();
            });

            window.addEventListener('resize', function() {
                engine.resize();
                
                document.documentElement.style.setProperty('--dummy', 'none');
                setTimeout(() => {
                    document.documentElement.style.removeProperty('--dummy');
                }, 0);
            });

            if ('ondeviceinfochange' in window) {
                window.addEventListener('deviceinfochange', function() {
                    document.documentElement.style.setProperty('--dummy', 'none');
                    setTimeout(() => {
                        document.documentElement.style.removeProperty('--dummy');
                    }, 0);
                });
            }
        });
    </script>
</body>
</html>
